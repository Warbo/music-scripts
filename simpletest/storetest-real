#!/usr/bin/env python

import math
import os
import subprocess
import sys
import time
import datetime

# TODO: Put these into a config file somewhere
store_location  = '/var/www/domains/wandisco.com/drupal7/htdocs'
result_location = '/tmp/test-results'
site            = {True:  'svn-training.wandisco.com',
                   False: 'default'}['-training' in sys.argv]

store_uri = subprocess.Popen(
                ['php',
                 '-r',
                 'require_once "' + \
                     store_location + '/sites/' + site + '/settings.php"; ' + \
                     'echo isset($base_url)? $base_url : "f";'],
                stdout=subprocess.PIPE,
                cwd=store_location).communicate()[0].strip()

if store_uri == 'f':
    print "Could not find $base_url"
    sys.exit(1)

now = datetime.datetime.fromtimestamp(time.time()).strftime('%Y-%m-%d-%H-%M')

def clean():
    # Poor man's closure
    cleaned = [False]
    def cleaner():
        """Clean up previous test cruft"""
        if not cleaned[0] and '-clean' in sys.argv:
            run('drush test-clean')
        cleaned.pop()
        cleaned.append(True)
    return cleaner
clean = clean()

def remove_previous(test=''):
    """Pass in a test's name to clear its previous debug output. Leave empty to
    clear all previous tests' output."""
    if '-clean' not in sys.argv:
        return

    # Clear old databases and files
    clean()

    # Remove old debug output
    try:
        subprocess.check_call(
            ''.join(['rm -f ',
                     store_location,
                     '/sites/default/files/simpletest/verbose/',
                     test,
                     '*.html']),
            shell=True,
            stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError:
        # Files not found; good, we're deleting them anyway!
        pass

def clear_cache():
    cleared = [False]
    def clearer():
        """Clear Drupal's cache, so that we use the latest test definitions."""
        if not cleared[0] and '-clear' in sys.argv:
            run('drush cc all')
        cleared.pop()
        cleared.append(True)
    return clearer
clear_cache = clear_cache()

def command(classes=[], methods=[]):
    """Build test commands. Any given arguments will be appended to the
    commands."""

    if len(classes) == 0:
        raise Exception('Must have classes to test')
    if len(classes) > 1 and len(methods) > 0:
        raise Exception('Cannot test specific methods of multiple classes')

    tee = ' 2>&1 | tee -a /tmp/test-run-' + now
    if len(methods) > 0:
        return ['drush test-run '         + \
                    classes[0]            + \
                    ' --methods=testRun,' + \
                    ','.join(methods)     + \
                    ' --uri='             + \
                    store_uri             + \
                    ' --xml='             + \
                    result_location       + \
                    tee]

    return ['drush test-run '     + \
                ','.join(classes) + \
                ' --uri='         + \
                store_uri         + \
                ' --xml='         + \
                result_location   + \
                tee]

run = lambda cmd: subprocess.check_call(cmd,
                                        cwd=store_location,
                                        shell=True)

# Read our arguments
# TODO: Make this more generic; get WANdisco from a config file!
args = [a for a in sys.argv if not a.startswith('-')]
if len(args) < 2 or 'WANdisco' in args:
    # Run the whole WANdisco group
    tests = ['WANdisco']
    remove_previous()
else:
    # Run specific tests
    tests = args[1:]

# Split apart whole groups/suites from specific methods
whole    = []
specific = []
for t in tests:
    {True:  specific,
     False: whole   }['::' in t].append(t)

# Clear the cache, if we're told to
clear_cache()

# Run the whole groups/suites
if len(whole) > 0:
    map(remove_previous, whole)
    for com in command(whole):
        try:
            run(com)
        except:
            print "Failed: " + com
        clean()

# Collect up specific methods
classes = {}
for (c, m) in [(s.split('::')[0], s.split('::')[1]) for s in specific]:
    if c not in classes:
        classes[c] = []
    if m not in classes[c]:
        classes[c].append(m)

map(remove_previous, classes.keys())

for c in classes:
    for com in command([c], classes[c]):
        try:
            run(com)
        except:
            print "Fail: " + com
        clean()
