#!/usr/bin/env runhaskell
{-# LANGUAGE FlexibleInstances #-}
import Distribution.Package
import Distribution.PackageDescription
import Distribution.PackageDescription.Parse
import Distribution.PackageDescription.PrettyPrint
import System.Environment
import System.IO

processPkg d x = out
  where pkg       = case parsePackageDescription x of
                         ParseFailed err  -> error (show err)
                         ParseOk _ result -> result
        pkg'      = pkg {
                        condLibrary     = process condLibrary
                      , condExecutables = process condExecutables
                      , condTestSuites  = process condTestSuites
                      , condBenchmarks  = process condBenchmarks
                      }
        process f = procDep (remove d) (f pkg)
        out       = showGenericPackageDescription pkg'

class HasDep a where
  procDep :: ([Dependency] -> [Dependency]) -> a -> a

instance (HasDep a) => HasDep (Maybe a) where
  procDep f = fmap (procDep f)

instance (HasDep a) => HasDep [a] where
  procDep f = fmap (procDep f)

instance (HasDep a) => HasDep (b, a) where
  procDep f = fmap (procDep f)

instance HasDep BuildInfo where
  procDep f bi = bi { targetBuildDepends = f (targetBuildDepends bi) }

instance HasDep Executable where
  procDep f x = x { buildInfo = procDep f (buildInfo x) }

instance HasDep TestSuite where
  procDep f x = x { testBuildInfo = procDep f (testBuildInfo x) }

instance HasDep Benchmark where
  procDep f x = x { benchmarkBuildInfo = procDep f (benchmarkBuildInfo x) }

instance HasDep Library where
  procDep f x = x { libBuildInfo = procDep f (libBuildInfo x) }

instance (HasDep b) => HasDep (CondTree a [Dependency] b) where
  procDep f ct = ct {
      condTreeData        = procDep f (condTreeData ct)
    , condTreeConstraints = f (condTreeConstraints ct)
    , condTreeComponents  = fmap process (condTreeComponents ct)
    }
    where process (a, b, mc) = (a, procDep f b, fmap (procDep f) mc)

remove d = filter (depNot d)

depNot d (Dependency n _) = unPackageName n /= d

main = do Just d  <- lookupEnv "DEP"
          content <- getContents
          putStrLn (processPkg d content)
