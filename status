#!/usr/bin/env python
"""Read a password then enter a REPL for posting messages to identi.ca"""

# Define this now, since its scope is quite wide
exit_commands = ('quit', 'exit')

# Define some useful functions. We use def/call/del to capture state in closures

def make_out():
    """Returns a function for printing to stdout."""
    from sys import stdout
    return lambda msg: (lambda _: (stdout.write(msg), stdout.flush()))
out = make_out()
del(make_out)

def make_dent():
    """Creates a function for denting (posting to identi.ca)."""
    from urllib import urlencode
    from getpass import getpass
    import urllib2 as u
    url     = 'http://identi.ca/api/statuses/update.xml'
    passman = u.HTTPPasswordMgrWithDefaultRealm()
    passman.add_password(None, url, 'warbo', getpass())
    opener  = u.build_opener(u.HTTPBasicAuthHandler(passman))
    req     = u.Request(url)
    return lambda msg: opener.open(req, urlencode({'status': msg}))
dent = make_dent()
del(make_dent)

def quit(_):
    """Exit the program."""
    print 'Bye!'
    from sys import exit
    exit(0)

# Handle messages based on their content. Works like LISP's cond; pop off
# (condition, function) pairs until condition is True, then run function(msg)
handle = lambda(msg): filter(lambda (x, y): x, [
    (len(msg) > 140,               out('Too long: ' + str(len(msg)) + '\n')),
    (msg in exit_commands,         quit),
    (True,                         dent)
])[0][1](msg.strip())

# Finally 'tie the knot' between identi.ca and stdin, to make our REPL
print 'To quit, type ' + ' or '.join(map(repr, exit_commands))
while True: handle(raw_input('> '))
